adding a simple endpoint to read prompts stored as text files in your codebase. Here's what I recommend:

1. Create a prompts directory structure
First, create a directory structure to organize your prompts:

mkdir prompts

2. Add the prompt management endpoint

import os
from pathlib import Path
// ...existing code...

@app.get("/prompts/{prompt_name}", tags=["prompts"])
async def get_prompt(prompt_name: str, api_key: str = Depends(get_api_key)):
    """Get a prompt by name from stored text files"""
    
    # Define the prompts directory
    prompts_dir = Path("prompts")
    
    # Sanitize the prompt name to prevent directory traversal
    safe_prompt_name = "".join(c for c in prompt_name if c.isalnum() or c in ('-', '_', '.'))
    
    # Look for the prompt file with .txt extension
    prompt_file = prompts_dir / f"{safe_prompt_name}.txt"
    
    # Check if file exists
    if not prompt_file.exists():
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Prompt '{prompt_name}' not found"
        )
    
    try:
        # Read the prompt content
        with open(prompt_file, 'r', encoding='utf-8') as f:
            prompt_content = f.read()
        
        return {
            "success": True,
            "prompt_name": prompt_name,
            "content": prompt_content,
            "file_path": str(prompt_file)
        }
        
    except Exception as e:
        logger.error(f"Error reading prompt file '{prompt_file}': {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to read prompt file: {str(e)}"
        )

@app.get("/prompts", tags=["prompts"])
async def list_prompts(api_key: str = Depends(get_api_key)):
    """List all available prompts"""
    
    prompts_dir = Path("prompts")
    
    # Create prompts directory if it doesn't exist
    prompts_dir.mkdir(exist_ok=True)
    
    try:
        # Get all .txt files in the prompts directory
        prompt_files = list(prompts_dir.glob("*.txt"))
        
        prompts = []
        for prompt_file in prompt_files:
            prompt_name = prompt_file.stem  # filename without extension
            try:
                # Get basic info about each prompt
                with open(prompt_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                    preview = content[:100] + "..." if len(content) > 100 else content
                
                prompts.append({
                    "name": prompt_name,
                    "file_path": str(prompt_file),
                    "size_chars": len(content),
                    "preview": preview
                })
            except Exception as e:
                logger.warning(f"Could not read prompt file '{prompt_file}': {str(e)}")
                prompts.append({
                    "name": prompt_name,
                    "file_path": str(prompt_file),
                    "error": str(e)
                })
        
        return {
            "success": True,
            "total_prompts": len(prompts),
            "prompts": prompts
        }
        
    except Exception as e:
        logger.error(f"Error listing prompts: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list prompts: {str(e)}"
        )

3. Create some example prompt files
Create some example prompts in the prompts directory:

# Create example prompts
echo "You are a helpful AI assistant. Please answer the user's question clearly and concisely." > prompts/general-assistant.txt

echo "Analyze the following data and provide insights:

Data: {data}

Please provide:
1. Key patterns or trends
2. Notable observations
3. Recommendations based on the analysis" > prompts/data-analysis.txt

echo "Generate a professional email response for the following scenario:

Context: {context}
Tone: {tone}
Key points to address: {key_points}

Please write a clear, professional email that addresses all the key points." > prompts/email-generator.txt


I suggest adding a simple endpoint to read prompts stored as text files in your codebase. Here's what I recommend:

1. Create a prompts directory structure
First, create a directory structure to organize your prompts:

2. Add the prompt management endpoint
3. Create some example prompt files
Create some example prompts in the prompts directory:

4. Optional: Add a Pydantic model for better response structure

// ...existing code...

class PromptResponse(BaseModel):
    success: bool
    prompt_name: str
    content: str
    file_path: str

class PromptListItem(BaseModel):
    name: str
    file_path: str
    size_chars: Optional[int] = None
    preview: Optional[str] = None
    error: Optional[str] = None

class PromptListResponse(BaseModel):
    success: bool
    total_prompts: int
    prompts: List[PromptListItem]

5. Usage Examples
Once deployed, you can use the endpoints like:

GET /prompts - List all available prompts
GET /prompts/general-assistant - Get the general assistant prompt
GET /prompts/data-analysis - Get the data analysis prompt